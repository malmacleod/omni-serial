
Name      pdpserial_main;

Assembly  0001;
Revision  P2 1.0;
PartNo    U1 ATF1508AS;
Device    f1508ispplcc84;

Company   Retrotronics.org;
Designer  Alan H.;
Location  None;
Date      September 2016;

property ATMEL { jtag=on };
PROPERTY ATMEL { preassign keep };
PROPERTY ATMEL { TMS_pullup=on };
PROPERTY ATMEL { TDI_pullup=on };
/* PROPERTY ATMEL { pin_keep OFF }; */
PROPERTY ATMEL { open_collector = DATA0, DATA1, DATA2, DATA3, DATA4, DATA5, DATA6, DATA7, DATA8, DATA9, DATA10, DATA11, INTERNAL_IO, C0, C1, SKIP, INT_RQST };



/***************************************************************************************

Version: 27-SEP-2016.

This code compiles without error in WinCupl V 5.30.4.

Functionality:

1. The board is selectable as the Console at Device Code 03/04 (with dipswitch RXA0 off)
or as the second SLU at Device Code 40/41 (with dipswitch RXA0 on). RXA0 is "RX ADDR"
Switch #6.
2. The Green LED (D3, LHS) lights when a character is being received.
3. The Yellow LED (D2, Centre) lights when a character is being transmitted.
4. The Red LED (D1, RHS) lights when interrupts are armed on this board.
5. All 3 LEDs are driven by level-triggered 100 mSec retrigerable one-shots.
6. Baud rate is fixed at 115,200 (be sure to set the FTDI to this speed via the PC).
7. The board requires a minimum of 1.5 stop bits on the receive side, and sends two
stop bits.

It can:

* Operate as the Console for OS/8 (when switch RXA0 is off).
* Boot OS/8 via SerialDisk (when switch RXA0 is on).

Status:

The board now appears to work OK - but requires further testing.

No robust testing has yet been done. Interrupt functionality has not been tested
(SerialDisk does not appear to use interrupts).

A few things to check if the board is not working for you:

  1. Remember to configure the FTDI UART (through the PC) to 115200, Mark, 7, 2 when
     using the board as an OS/8 console. For SerialDisk, configure for 115200, N, 8, 2.
  2. The FTDI UART comes in "FEMALE" and "MALE" versions. Physically these appear to be
     identical.  The FEMALE/MALE designation only affects whether Pins 2 and 3 are
     respectively TX or RX.  Change the "Pin 11" and "Pin 9" lines below to suit the
     gender of the FTDI device installed in your board.

***************************************************************************************/


/* MALE FTDI: TX = 9, RX = 11 */
/* FEMALE FTDI: TX = 11, RX = 9 */

Pin 11  = UART_TX;  /* Current configured for FEMALE FTDI */
Pin 9 = UART_RX;    /* Current configured for FEMALE FTDI */

/* Pin 4 = UART_RX; */  /* Alternate UART */
/* Pin 5 = UART_TX; */  /* Alternate UART */

/* Dipswitches switch to GND (ON = 0V, OFF = 5V) */
Pin 18 = !RXA5; /* Switch 1 of RX ADDR */
Pin 17 = !RXA4; /* Switch 2 of RX ADDR */
Pin 16 = !RXA3; /* Switch 3 of RX ADDR */
Pin 15 = !RXA2; /* Switch 4 of RX ADDR */
Pin 10 = !RXA1; /* Switch 5 of RX ADDR */
Pin 12 = !RXA0; /* Switch 6 of RX ADDR */

Pin 76 = !TXA5; /* Switch 1 of TX ADDR */
Pin 73 = !TXA4; /* Switch 2 of TX ADDR */
Pin 70 = !TXA3; /* Switch 3 of TX ADDR */
Pin 69 = !TXA2; /* Switch 4 of TX ADDR */
Pin 68 = !TXA1; /* Switch 5 of TX ADDR */
Pin 67 = !TXA0; /* Switch 6 of TX ADDR */

Pin 81 = CLK;  /* 1.8432 MHz XTAL oscillator input. */

Pin 79 = LED0; /* D1. Red LED (RHS). Active High.       */
Pin 75 = LED1; /* D2. Yellow LED (Centre). Active High. */
Pin 77 = LED2; /* D3. Green LED (LHS). Active High.     */

/* OMNIBUS SIGNALS */
Pin 41 = !OMNI_IO_PAUSE; /* CD1, Input, Active Low  */
Pin 40 = TP3;	       /* CH2, Input, Active High */
Pin 33 = INIT;           /* CR1, Input, Active High */

Pin 36 = INTERNAL_IO;    /* CL1, Output, Active Low */
Pin 39 = C0;             /* CE1, Output, Active Low */
Pin 37 = C1;             /* CH1, Output, Active Low */
Pin 31 = SKIP;           /* CS1, Output, Active Low */
Pin 34 = INT_RQST;       /* CP1, Output, Active Low */

Pin 58 = !MD3;  /* AP1, Input, Active Low. Device Code 4x   */
Pin 55 = !MD4;  /* BK1, Input, Active Low. Device Code 2x   */ 
/* Note: KL8-E schematic (figure 3-112 on page 3-160 of PDP-8/e Processor
Maintenance Manual) erroneously shows MD4 as being pin BR1 */
Pin 51 = !MD5;  /* BL1, Input, Active Low. Device Code 1x   */
Pin 52 = !MD6;  /* BM1, Input, Active Low. Device Code x4   */
Pin 49 = !MD7;  /* BP1, Input, Active Low. Device Code x2   */
Pin 30 = !MD8;  /* DK1, Input, Active Low. Device Code x1   */
Pin 29 = !MD9;  /* DL1, Input, Active Low. Operation Code 4 */
Pin 28 = !MD10; /* DM1, Input, Active Low. Operation Code 2 */
Pin 27 = !MD11; /* DP1, Input, Active Low. Operation Code 1 */

/* Omnibus Data Bus. DATA0 is most-sig-bit, DATA11 is least-sig-bit */
Pin 65 = DATA0;  /* AR1, Bi-Directional, Active Low, Unused */
Pin 56 = DATA1;  /* AS1, Bi-Directional, Active Low, Unused */
Pin 57 = DATA2;  /* AU1, Bi-Directional, Active Low, Unused */
Pin 54 = DATA3;  /* AV1, Bi-Directional, Active Low, Unused */
Pin 50 = DATA4;  /* BR1, Bi-Directional, Active Low */
Pin 48 = DATA5;  /* BS1, Bi-Directional, Active Low */
Pin 45 = DATA6;  /* BU1, Bi-Directional, Active Low */
Pin 46 = DATA7;  /* BV1, Bi-Directional, Active Low */
Pin 24 = DATA8;  /* DR1, Bi-Directional, Active Low */
Pin 25 = DATA9;  /* DS1, Bi-Directional, Active Low */
Pin 22 = DATA10; /* DU1, Bi-Directional, Active Low */
Pin 21 = DATA11; /* DV1, Bi-Directional, Active Low */

/* State machine definitions for both RX and TX */
$DEFINE S_INIT  'b'000000000000
$DEFINE S_IDLE  'b'000000000001
$DEFINE S_START 'b'000000000010
$DEFINE S_BIT0  'b'000000000100
$DEFINE S_BIT1  'b'000000001000
$DEFINE S_BIT2  'b'000000010000
$DEFINE S_BIT3  'b'000000100000
$DEFINE S_BIT4  'b'000001000000
$DEFINE S_BIT5  'b'000010000000
$DEFINE S_BIT6  'b'000100000000
$DEFINE S_BIT7  'b'001000000000
$DEFINE S_STOP1 'b'010000000000
$DEFINE S_STOP2 'b'100000000000

/* UART TX-related nodes */
pinnode = [TC0..3];    /* 4-bit TX bit counter */
pinnode = [TS11..0];   /* TX state machine */
pinnode = [TSR0..7];   /* TX shift register */
Pinnode = STROBE;

/* UART RX-related nodes */
pinnode = [RC0..3];    /* 4-bit RX bit counter */
pinnode = [RS11..0];   /* RX state machine */
pinnode = [RSR0..7];   /* RX shift register */
pinnode = UART_RX_D1;  /* Used to detect falling edge of RX start bit */
pinnode = CNTR_START;  /* Used to detect centre of RX start bit */

/* Counters for LEDs */
pinnode = [TCK13..0];  /* Counts to 1/150 second and rolls over */
pinnode = [TLC3..0];   /* TX LED: Counts to 1/10 second and rolls over */
pinnode = [RLC3..0];   /* RX LED: Counts to 1/10 second and rolls over */
pinnode = [ILC3..0];   /* INT-ENBL LED: Counts to 1/10 second and rolls over */

/* OMNIBUS device decode nodes */
pinnode = RX_FLAG;
pinnode = TX_FLAG;
pinnode = RDRRUN;
pinnode = INT_EN;


/* Board is fitted with a 1.8432 MHz XTAL */
/* UART bit counter: 16 CLK ticks/bit = 8.680556 uSec/bit = 115,200 baud */


/* Decode OMNIBUS device addresses */
RX_ADRS = OMNI_IO_PAUSE & ((!RXA0 & !MD3 & !MD4 & !MD5 & !MD6 &  MD7 &  MD8) # (RXA0 & MD3 & !MD4 & !MD5 & !MD6 & !MD7 & !MD8)); /* 03 or 40 */
TX_ADRS = OMNI_IO_PAUSE & ((!RXA0 & !MD3 & !MD4 & !MD5 &  MD6 & !MD7 & !MD8) # (RXA0 & MD3 & !MD4 & !MD5 & !MD6 & !MD7 &  MD8)); /* 04 or 41 */

INTERNAL_IO = !(RX_ADRS # TX_ADRS);

RX_FLAG.d = 'b'1;   /* Value to clock into this flag register    */
RX_FLAG.ck = RS11;  /* Activate flag at centre of RX Stop Bit 1 */
RX_FLAG.ar = (RX_ADRS & !MD9 & !MD10 & !MD11 & TP3) # (RX_ADRS & MD10 & !MD11 & TP3) # INIT; /* Clear the RX
Flag on receiving Device Code 6030, 6032 or 6036 */

C0 = !(RX_ADRS & MD10 & !MD11);                              /* Device Code 6032 or 6036       */
C1 = !((RX_ADRS & MD9 &  !MD11) # (RX_ADRS & MD10 & !MD11)); /* Device Code 6032, 6034 or 6036 */

RDRRUN.D = 'B'0;
RDRRUN.CK = RS2;  /* Clear RDRRUN during RX start bit. This differs from the KL8-E approach */
RDRRUN.AP = RX_ADRS & MD10 & !MD11 & TP3; /* Device Code 6032 or 6036 */
RDRRUN.AR = INIT;

[DATA0..3].D = 'b'1111;  /* This stops the fitter using these pins for other purposes */
[DATA4..11].D = ![RSR7..0];
[DATA0..11].CK = RS11;   /* Centre of RX Stop Bit 1 */
[DATA0..11].OE = RX_ADRS & MD9 & !MD11; /* Device code 6034 or 6036 */
[DATA0..11].AR = INIT;

TX_FLAG.d = 'b'1;
TX_FLAG.ck = TS10; /* Set flag at start of Stop Bit 1 */
TX_FLAG.ap = (TX_ADRS & !MD9 & !MD10 & !MD11 & TP3); /* Dev code 6040 */
TX_FLAG.ar = (TX_ADRS & MD10 & !MD11 & TP3) # INIT;  /* Dev code 6042 or 6046 */

SKIP = !((RX_ADRS & !MD9 & !MD10 & MD11 & RX_FLAG) # (TX_ADRS & !MD9 & !MD10 & MD11 & TX_FLAG) # (TX_ADRS & MD9 & !MD10 & MD11 & INT_EN & (RX_FLAG # TX_FLAG))); /* Device Code 6031, 6041 or 6045 */

STROBE.D = 'B'0; /* Clear the STROBE once we start sending the byte */
STROBE.CK = TS2;
STROBE.AP = TX_ADRS & MD9 & !MD11 & TP3; /* Device Code 6044 or 6046 */
STROBE.AR = INIT;

/* [TSR7..0].d  = ![DATA4..11]; */  /* Copies ACC to TX shift register */
TSR7.D = !DATA4.IO;
TSR6.D = !DATA5.IO;
TSR5.D = !DATA6.IO;
TSR4.D = !DATA7.IO;
TSR3.D = !DATA8.IO;
TSR2.D = !DATA9.IO;
TSR1.D = !DATA10.IO;
TSR0.D = !DATA11.IO;
[TSR7..0].ck = STROBE;   /* Latch the TX data when we receive DC 6044 or 6046 */
[TSR7..0].ar = 'b'0;

/* Configure the INT-ENBL flip flop */
INT_EN.d = !DATA11;
INT_EN.ck = RX_ADRS & MD9 & !MD10 & MD11 & TP3; /* Dev code 6035 */
INT_EN.ar = INIT; /* Note: This is OPPOSITE of KL8-E behaviour - which appear to ARM interrupts on initialisation */
/* INT_EN.ar = 'b'0; */

INT_RQST = !(INT_EN & (RX_FLAG # TX_FLAG));


/* Setup a free running counter with a period of 12,288 / 1,843,200 = 1/150 sec */
TICK_ROLL = !TCK13 & !TCK12 & !TCK11 & !TCK10 & !TCK9 & !TCK8 & !TCK7 & !TCK6 & !TCK5 & !TCK4 & !TCK3 & !TCK2 & !TCK1 & !TCK0; /*      Tick = 0 */
TICK_CLR  =  TCK13 &  TCK12 & !TCK11 & !TCK10 & !TCK9 & !TCK8 & !TCK7 & !TCK6 & !TCK5 & !TCK4 & !TCK3 & !TCK2 & !TCK1 & !TCK0; /* Tick = 12,288 */

TCK13.t = TCK0 & TCK1 & TCK2 & TCK3 & TCK4 & TCK5 & TCK6 & TCK7 & TCK8 & TCK9 & TCK10 & TCK11 & TCK12;
TCK12.t = TCK0 & TCK1 & TCK2 & TCK3 & TCK4 & TCK5 & TCK6 & TCK7 & TCK8 & TCK9 & TCK10 & TCK11;
TCK11.t = TCK0 & TCK1 & TCK2 & TCK3 & TCK4 & TCK5 & TCK6 & TCK7 & TCK8 & TCK9 & TCK10;
TCK10.t = TCK0 & TCK1 & TCK2 & TCK3 & TCK4 & TCK5 & TCK6 & TCK7 & TCK8 & TCK9;
TCK9.t  = TCK0 & TCK1 & TCK2 & TCK3 & TCK4 & TCK5 & TCK6 & TCK7 & TCK8;
TCK8.t  = TCK0 & TCK1 & TCK2 & TCK3 & TCK4 & TCK5 & TCK6 & TCK7;
TCK7.t  = TCK0 & TCK1 & TCK2 & TCK3 & TCK4 & TCK5 & TCK6;
TCK6.t  = TCK0 & TCK1 & TCK2 & TCK3 & TCK4 & TCK5;
TCK5.t  = TCK0 & TCK1 & TCK2 & TCK3 & TCK4;
TCK4.t  = TCK0 & TCK1 & TCK2 & TCK3;
TCK3.t  = TCK0 & TCK1 & TCK2;
TCK2.t  = TCK0 & TCK1;
TCK1.t  = TCK0;
TCK0.t  = 'b'1;

[TCK13..0].ce = 'b'11111111111111;
[TCK13..0].ck = CLK;
[TCK13..0].ar = TICK_CLR # INIT;

/* TX LED code follows */
TLC_FULL = TLC3 & TLC2 & TLC1 & TLC0; /* Equals 0.1 seconds */

TLC3.t  = TLC0 & TLC1 & TLC2;
TLC2.t  = TLC0 & TLC1;
TLC1.t  = TLC0;
TLC0.t  = 'b'1;

[TLC3..0].ce = 'b'1111;
[TLC3..0].ck = TICK_ROLL;  /* Inrement the TLC timer every 1/150 second        */
[TLC3..0].ar = INIT # TS2; /* Reset TX LED Timer at start of each TX start bit */

LED1.D = 'b'0;
LED1.CK = TLC_FULL;  /* Turn LED1 (D2, Yellow, Centre) off when timer expires      */
LED1.AP = TS2;       /* Turn LED1 (D2, Yellow, Centre) on at start of TX start bit */
LED1.AR = INIT;

/* RX LED code follows */
RLC_FULL = RLC3 & RLC2 & RLC1 & RLC0; /* Equals 0.1 seconds */

RLC3.t  = RLC0 & RLC1 & RLC2;
RLC2.t  = RLC0 & RLC1;
RLC1.t  = RLC0;
RLC0.t  = 'b'1;

[RLC3..0].ce = 'b'1111;
[RLC3..0].ck = TICK_ROLL;  /* Increment the RLC timer every 1/150 second       */
[RLC3..0].ar = INIT # RS2; /* Reset RX LED Timer at start of each RX start bit */

LED2.D = 'b'0;
LED2.CK = RLC_FULL;  /* Turn LED2 (D3, Green, LHS) off when timer expires      */
LED2.AP = RS2;       /* Turn LED2 (D3, Green, LHS) on at start of RX start bit */
LED2.AR = INIT;

/* INT-ENBL LED code follows */
ILC_FULL = ILC3 & ILC2 & ILC1 & ILC0; /* Equals 0.1 seconds */

ILC3.t  = ILC0 & ILC1 & ILC2;
ILC2.t  = ILC0 & ILC1;
ILC1.t  = ILC0;
ILC0.t  = 'b'1;

[ILC3..0].ce = 'b'1111;
[ILC3..0].ck = TICK_ROLL;     /* Increment the ILC timer every 1/150 second     */
[ILC3..0].ar = INIT # INT_EN; /* Reset INT-ENBL LED Timer when INTs are enabled */

LED0.D = 'b'0;
LED0.CK = ILC_FULL;  /* Turn LED0 (D1, Red, RHS) off when timer expires      */
LED0.AP = INT_EN;    /* Turn LED0 (D1, Red, RHS) on when INTs are turned on */
LED0.AR = INIT;

/* UART TX timing */
TX_BIT_FULL = TC3 & TC2 & TC1 & TC0;

TC3.t = TC0 & TC1 & TC2;
TC2.t = TC0 & TC1;
TC1.t = TC0;
TC0.t = 'b'1;

[TC3..0].ce = 'b'1111;
[TC3..0].ck = CLK;
[TC3..0].ar = TS0; /* S_IDLE; */  /* Hold at zero until FSM released via write strobe */

/* State machine for TX data */
field tx_state = [TS11..0];
tx_state.ck = CLK;

Sequence tx_state {
	present S_INIT
            next S_IDLE;
	present S_IDLE
            if (STROBE) next S_START;
            default next S_IDLE;
	present S_START
            if (TX_BIT_FULL) next S_BIT0;
            default next S_START;
	present S_BIT0
            if (TX_BIT_FULL) next S_BIT1;
            default next S_BIT0;
	present S_BIT1
            if (TX_BIT_FULL) next S_BIT2;
            default next S_BIT1;
	present S_BIT2
            if (TX_BIT_FULL) next S_BIT3;
            default next S_BIT2;
	present S_BIT3
            if (TX_BIT_FULL) next S_BIT4;
            default next S_BIT3;
	present S_BIT4
            if (TX_BIT_FULL) next S_BIT5;
            default next S_BIT4;
	present S_BIT5
            if (TX_BIT_FULL) next S_BIT6;
            default next S_BIT5;
	present S_BIT6
            if (TX_BIT_FULL) next S_BIT7;
            default next S_BIT6;
	present S_BIT7
            if (TX_BIT_FULL) next S_STOP1;
            default next S_BIT7;
	present S_STOP1
            if (TX_BIT_FULL) next S_STOP2;
            default next S_STOP1;
	present S_STOP2
          if (TX_BIT_FULL) next S_IDLE;
            default next S_STOP2;
}


UART_TX =  TS0         /* S_IDLE  */
	# (TS2 & TSR0)   /* S_BIT0  */
	# (TS3 & TSR1)   /* S_BIT1  */
	# (TS4 & TSR2)   /* S_BIT2  */
	# (TS5 & TSR3)   /* S_BIT3  */
	# (TS6 & TSR4)   /* S_BIT4  */
	# (TS7 & TSR5)   /* S_BIT5  */
	# (TS8 & TSR6)   /* S_BIT6  */
	# (TS9 & TSR7)   /* S_BIT7  */
	#  TS10          /* S_STOP1 */
	#  TS11;         /* S_STOP2 */


/* Detect commencement of RX start bit, to transition IDLE -> START state */
UART_RX_D1.d  = UART_RX;
UART_RX_D1.ck = CLK;
UART_RX_D1.ce = 'b'1;
UART_RX_D1.ar = 'b'0;


/* EDGE_DETECT = !UART_RX & UART_RX_D1; */  /* falling */
EDGE_DETECT = !UART_RX;


/* Detect centre of RX start bit */
CNTR_START.d  = RS1 & RX_BIT_HALF;
CNTR_START.ck = CLK;
CNTR_START.ar = INIT /* # RS10 */;


/* UART RX timing */
RX_BIT_HALF = !RC3 & RC2 & RC1 & RC0;
RX_BIT_FULL =  RC3 & RC2 & RC1 & RC0;

RC3.t = RC0 & RC1 & RC2;
RC2.t = RC0 & RC1;
RC1.t = RC0;
RC0.t = 'b'1;

[RC3..0].ce = 'b'1111;
[RC3..0].ck = CLK;
[RC3..0].ar = RS0 # CNTR_START; /* S_IDLE or after centre of S_START */


/* State machine for RX data */
field rx_state = [RS11..0];
rx_state.ck = CLK;

Sequence rx_state {
	present S_INIT
		next S_IDLE;
	present S_IDLE                        /* Current state = RS0. Waiting for START bit negative edge */
		if (EDGE_DETECT)  next S_START;
		default next S_IDLE;
	present S_START                       /* Current state = RS1. Waiting for centre of START bit */
		if (RX_BIT_HALF) next S_BIT0;
		if (UART_RX) next S_IDLE;       /* Return to S_IDLE if false start */
		default next S_START;
	present S_BIT0
		if (RX_BIT_FULL) next S_BIT1;
		default next S_BIT0;
	present S_BIT1
		if (RX_BIT_FULL) next S_BIT2;
		default next S_BIT1;
	present S_BIT2
		if (RX_BIT_FULL) next S_BIT3;
		default next S_BIT2;
	present S_BIT3
		if (RX_BIT_FULL) next S_BIT4;
		default next S_BIT3;
	present S_BIT4
		if (RX_BIT_FULL) next S_BIT5;
		default next S_BIT4;
	present S_BIT5
		if (RX_BIT_FULL) next S_BIT6;
		default next S_BIT5;
	present S_BIT6
		if (RX_BIT_FULL) next S_BIT7;
		default next S_BIT6;
	present S_BIT7
		if (RX_BIT_FULL) next S_STOP1;
		default next S_BIT7;
	present S_STOP1
		if (RX_BIT_FULL) next S_STOP2;
		default next S_STOP1;
	present S_STOP2
 	        if (RX_BIT_FULL) next S_IDLE;
 		default next S_STOP2;
}	


[RSR0..7].D = UART_RX;
[RSR0..7].AR = 'b'0;
[RSR0..7].CE = 'b'11111111;
RSR0.CK = RS3; /* latch bit 0 at centre of bit time */
RSR1.CK = RS4; /* latch bit 1 one bit time later */
RSR2.CK = RS5; /* latch bit 2 one bit time later */
RSR3.CK = RS6; /* latch bit 3 one bit time later */
RSR4.CK = RS7; /* latch bit 4 one bit time later */
RSR5.CK = RS8; /* latch bit 5 one bit time later */
RSR6.CK = RS9; /* latch bit 6 one bit time later */
RSR7.CK = RS10; /* latch bit 7 one bit time later */
